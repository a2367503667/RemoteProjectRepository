#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

/*
	C++异常的优势：

	1、不会返回异常的标记值，它会直接抛出返回的标记值到try{}catch{}代码当中进行处理，这样能够
	   很好地避免"无法区分返回值含义"的问题；

	2、异常可以抛出一个对象，而我们知道对象里面可以有很多成员，这样就能够携带更多的提示信息，
	   有助于我们对异常做更好地处理
	
	3、返回值用户可以忽略，但是异常不行，只能一直往上抛出(即往主调函数抛)，如果当前主调函数解决不了
	就继续往上跑，抛到main函数还不能解决就会直接终止程序(或直接报错)；

	4、(对第3点补充)如果匹配的处理未找到(也就是找不到处理异常catch的类型)，则会运行函数terminate自动
	   调用未匹配到的异常类型，这个terminate函数的省略功能就是about函数，会直接终止程序

	5、C++异常处理使得异常的引发和异常的处理不必要在一个函数当中，可以在不同的函数当中进行解决，这样
	   底层的函数就可以着重解决具体的问题，而不必要过多考虑异常的处理。上层的调用者可以在适当的位置
	   设计对不同类型异常的处理方式(这里的"底层"是指主调函数，"上层"是指被调函数)

	6、由第5点可以知道，可以逐层往上抛异常，只要当前异常未处理，都可以往上抛出，交给上一层调用函数
	   进行处理即可
*/

class Maker
{
public:
	void printMes()
	{
		std::cout << "Maker：除数不能为0" << std::endl;
	}
};

int func01(int a, int b)
{
	if (b == 0)
	{
		// 异常可以抛出对象(这样可以携带更多的信息)
		// throw Maker();
		throw 3.14;
	}
	return a / b;
}

void test01()
{
	int a = 10;
	int b = 0;

	try
	{
		func01(a, b);
	}
	catch (int)
	{
		std::cout << "int：除数不能为0" << std::endl;
	}
	catch (Maker &e) // 这里可以利用对象去输出提示信息
	{
		e.printMes();
	}
	catch (...) // 这个表示任意类型(一般抛出的类型如果上面都没有，就会进入这个默认类型中进行处理)
	{
		// 不想处理异常，可以往上抛出(即抛给调用本函数的函数)
		// 其中这里可以重新写抛出对应的值，也可以不给值(不给值默认抛出上次那个值)
		throw;
	}

}



int main()
{
	try
	{
		test01();
	}
	catch (double)
	{
		std::cout << "在main函数中处理异常" << std::endl;
	}

	return 0;
}
