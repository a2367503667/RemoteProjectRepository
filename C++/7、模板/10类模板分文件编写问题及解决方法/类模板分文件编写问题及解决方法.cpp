#include "MyClass.hpp"

/*

	头文件为什么不能够写函数体实现？
	
	1、首先我们要知道，头文件被包含到cpp或c文件中时，都会在预处理阶段进行展开
	   简单来说就是将头文件里面的内容进行赋值粘贴，到当前的cpp或c文件当中；

	2、头文件中即使有对头文件重复包含情况进行处理(如：#pragma once 或 #ifndef)，在只对当前
	   cpp或c文件有效，也就是说，这个定义只能用在当前文件，即"MyClass.cpp"包含了"MyClass.hpp"文件
	   和"10类模板分文件编写问题及解决方法.cpp"包含"MyClass.hpp"文件没有任何联系，反正就是头文件
	   重复包含的判断只作用于当前文件(这个必须要谨记)

	3、假设一个场景，"MyClass.hpp"文件里面实现了函数func01()，且"MyClass.cpp"文件和"10类模板分文
	   件编写问题及解决方法.cpp"文件都包含了"MyClass.hpp"头文件，在预处理过程中，这两个cpp文件都
	   会进行头文件展开，这样就会存在两个func01()，由于cpp文件是单独编译的，语法不会存在任何问题
	   但是在链接过程中，"MyClass.cpp"文件和"10类模板分文件编写问题及解决方法.cpp"文件都有func01()
	   函数体，这就会出现重定义，也就是会报出"找到一个或多个重定义的符号"的错误，这也就是为什么
	   我们不能够将函数体的实现写在头文件中(因为总会存在两个文件都包含了同一个头文件的情况出现，这
	   样在链接过程就会很容易出现链接错误)

	   以上就讲解了，为什么不能够在头文件中实现函数(这个很重要，下面知识需要用到)
*/

/*
	q1:
	为什么我们在cpp文件中，对类模板成员函数进行实现，然后包含头文件里面的声明会出现报错？
	明明我们在正常的类和函数中是可以使用的，为什么这里会报错？

	ans1(回答):
	因为类模板是需要进行二次编译的，第一次编译是检查类模板本身是否具有语法或其他错误，但是第
	二次编译是需要将类型传入类模板中，再次进行编译的，但是我们在main文件中调用此类模板，并给予
	类模板数据类型时，发现在本文件中找不到类模板成员函数的函数体(因为我们包含进来的hpp只有声明
	没有实现，并且我们并不能直接去访问"MyClass.cpp"的函数体，因为编译是一个个cpp或c文件单独进行
	编译的，不会牵扯到其他的文件)，此时我们发现编译到main文件时，没有类模板的成员函数主体，那编
	译器就没办法将类模板的数据类型代入成员函数体中再次进行编译，这就导致运行时错误

	solu(解决):
	为了解决上面这种问题，我们只能将类模板的成员函数实现写在hpp文件里面，然后当我们main文件预处理
	时，对hpp文件展开，就能够在编译过程中找到类模板的成员函数体，就不会报错了。其实不仅仅只是类
	模板会出现这个问题，在函数模板中也会出现这个问题，也就是我们在cpp文件中实现了一个函数模板，然后
	在hpp文件中进行声明，在main函数中调用也会出现上面那种无法运行的情况，其实同样是二次编译时，传入
	参数后编译器没办法找到函数的实现体，没办法完成二次编译才会报的错误

	q2:
	但是问题又来了，我们上面才说了，如果把函数的实现写在头文件中的话，那当别的cpp文件包含之后
	链接不就会出现"找到一个或多个重定义的符号"的错误吗？并且这里我们也验证过了，我们也在MyClass.cpp
	文件中包含了头文件"MyClass.hpp"，程序运行并没有报错，这是为什么？

	ans2:
	因为对于类来说，每个成员函数前面的签名默认加了inline关键字，这个在以前学过，就是内联函数
	也就是说如果在函数体中加入内联函数关键字"inline"，那在链接过程中就会去掉多份重复的函数，只会
	保留一份函数，这也就是为什么多个cpp文件中都包含同一个具有实现函数体的头文件都不会报错的原因
	而对于函数模板，我们也只能在头文件中进行函数体实现，但是需要我们手动加上inline关键字，否则
	多个文件包含hpp文件时，又会报出"找到一个或多个重定义的符号"的错误(其实普通函数也可以在前面
	加上inline，去规避多文件包含同一个头文件的链接错误，但是严禁在头文件中写普通函数的实现，这
	样写虽然可以规避错误，但是在开发中是极其不规范的，而且命名空间也不要写在头文件中，这也是严禁的)

	以上就是我们需要讲解的所有注意事项
*/

int main()
{
	Maker<std::string, int> m("张三", 20);
	m.printMes();

	int a = 10;
	func01(a);

	return 0;
}
