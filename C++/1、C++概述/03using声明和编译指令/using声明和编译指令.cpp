#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;

namespace A
{
	int  a = 10;
	int b = 20;
	int c = 30;
}

// ::叫做作用域运算符
void test01()
{
	// using的用法
	// 因为使用A命名空间里面的成员都需要加A::，这样有时候就很不方便，特别麻烦
	// 所以用using A::a;
	// 在这以后使用a都不需要加A::了，就会比较方便
	// 也就是说using声明是让命名空间中某个标识符可以直接使用
	// 这句话的意思是，告诉编译器下面的a是使用命名空间A里面的a的意思(using声明)
	using A::a;
	cout << "a = " << a << endl;

	// 但是这里有一个二义性，就是如果下面定义相同变量的a，那就会报错
	// 因为using A::a相当于定义了一个变量a
	// 虽然是相当于在里面定义了a，但是内存是在全局区
	// int a = 50;  这样表示重定义，编译会报错
}

void test02()
{
	// 但是如果命名空间里面有很多变量或者函数，一个个都需要using那就很麻烦
	// 因此可以这样做，如下：
	// 下面这句话其实就相当于打开“A的房间门”，然后可以去访问A里面的数据
	// 但是如果你局部的区域里面有对应的变量a，那么会优先去使用局部空间的a，如果没有a才会去使用
	// “A的房间门”里的a，也就是遇到就近原则时，用的就是局部里的a
	// 不管a是不是写在using namespace A前面，都是优先使用a
	// 但是如果有两个命名空间都打开了即using namespace A;  using namespace B;
	// 并且下面都有a变量，那么此时就需要指明使用哪个，也就是使用(空间名::)区分一下
	using namespace A; //在这个函数内，都可以使用A命名空间里面的变量，不需要加A::，如下：
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;

	namespace AA = A; // 给命名空间取别名，后面的数据可以使用AA去访问命名空间里面的成员

	// 但是这里不会存在二义性，就是下面再定义一个相同变量的a也不会报错


	// 为什么这里不会报错呢？因为这里相当于是在外面写了个全局变量a，下面是局部变量a，这是不会报错的
	// 但是using ::a，就相当于在函数内定义了一个a的变量，那属于重定义
	int a = 100;
	cout << "a = " << a << endl; // 就近原则，因为在上面定义了a并初始化为100
}

int main()
{
	test01();
	return 0;
}
