#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include "test.h"
using namespace std;


/*
* 命名空间：其实就是解决一些事情，就是多个人开发有可能就会遇到相同的名字(相同名字很可能编译报错)
*			就例如：函数、变量等等，为了解决这个问题，就提出命名空间，解决名字重复的问题
* 
* 
* 命名空间的注意事项：1、命名空间只能写在全局区域，不能写在函数里面；
*					  2、命名空间可以嵌套命名空间；
*					  3、命名空间是开放的，随时可以加入新成员，但是新成员只能在加入之后才能使用；
*					  4、匿名命名空间；
*					  5、命名空间可以取别名；
*					  6、分文件编写代码时，如果.h文件中有两个命名空间，但是里面的成员函数或者成员变量同名
*						 时，在.cpp文件中实现函数时，需要加上命名空间
*/

// 命名空间里面可以放变量、函数、结构体、类等
namespace A{ // A是空间的名字
	int a;
	void func()
	{

	}
	struct Person{};
	class Animal{};
}

// 命名空间可以嵌套命名空间
namespace Maker 
{
	int a;
	namespace B {
		int b = 100;
	}

}

// 因为函数定义在Maker::c之前，所以会报错
//void test()
//{
//	cout << Maker::c << endl;
//

// 注：这个不是两个命名空间，是一个，只是在这个命名空间里加了个新成员而已
// 这里就是直接在上面那个Maker里面加int c = 30;
namespace Maker
{
	// 虽然是写在命名空间里面，其实本质上还是全局变量，只不过被限定在大括号里面了
	// 即作用域在大括号里
	int c = 30;
}
// c = 20; 这句话显示报错，已经超出命名空间的作用域

// 匿名命名空间
// 只能当前文件使用，因为没有名字，类似于static int d = 80;
// 不希望别的文件使用这个变量，就可以命名为匿名命名空间
// 其实这个就是全局变量，而且是静态(static)全局变量
// 用的时候直接写d就行，如果局部变量有d，那就写::d，用法和全局变量一模一样
namespace 
{
	int d = 80;
}

// 命名空间取别名
// 其实也是为了解决重名问题，命名空间取别名就可以避免命名空间名字发生冲突
// 或者是命名空间的名字可能起的不太好，不太明白含义，那就可以给那个命名空间取别名
void test01()
{
	// 取别名其实也是方便使用命名空间名字
	//			新名字     旧名字
	namespace nameMaker = Maker;
	cout << nameMaker::a << endl;
}




int mya = 10;
int main(int argc, char* argv[])
{
	int mya = 20;
	// 就近原则(哪个近就打印谁)
	cout << "mya = " << mya << endl;
	
	// 如果我就是要打印全局的怎么办？
	// 那就使用作用域运算符::
	cout << "::mya = " << ::mya << endl;
	// 像前面那样，::前面没有写东西，那就默认全局
	// 但是前面写了命名空间，即“命名空间::”，那就是访问命名空间的变量，如下：
	// 所以::是访问某个作用域里面的成员
	cout << "Maker::c = " << Maker::c << endl;

	// 嵌套又如何访问呢？
	// 嵌套就写多层，例：访问嵌套命名空间的b，如下：
	cout << "Maker::B::b = " << Maker::B::b << endl;

	// 注：如果你写的一些函数去访问命名空间的成员，必须要在命名空间后面定义
	//	   不然会编译报错，因为在命名空间之前没有对应的成员变量，不可能访问，例：
	// 这个就是一个很好的例子
	// 显示c不是Maker的成员
	// test(); 

	// 匿名命名空间的使用：只能在当前文件中使用，下面就是使用案例
	cout << "d = " << d << endl;
	
	// 出现1个无法解析的外部命令表示链接出现错误了
	// 两个命名空间有同名，需要指明这个函数是定义哪个命名空间的
	myMaker1::func(); 

	return 0;
}
