#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

using namespace std;

/*
	总结：其实本质上引用也是有相应的空间的，它就是一个指针，是一个type(类型)* const常指针，例(int* const)
	也就是说它本身的值是不能被改变的，这样就是为什么一旦引用确定了对象就不能修改的本质，并且当
	int &ref = n;时 编译器其实在内部会做一个处理，int* const ref = &n;，也就是ref存的是n的指针，只是我们
	在用引用名ref修改n的值为5，编译器帮我们做一件事情，*ref=5;其实就相当于C语言中给指针进行解引用的操作而已
	就是便利我们不用在ref前面加解引用符(*)，而在函数传递时，它就会做这样的操作：

	void func(int &nArg) // 第一部分：这里相当于 int* const nArg = &n;
	{					 // 第二部分：其实就是把ref的值传给nArg，也就是把n的指针传给nArg
							因为ref=&n(这里是n的指针)，函数参数传递是值传递，也就是把ref的值传给nArg
							本质上还是int* const nArg = &n;
		// 这里就相当于C语言的 *nArg=8;
		nArg=8; 
	}

	int main()
	{
		第一部分：
		int n;
		n=5;
		// 这个操作本质上就是把&n传过去，给指针nArg接收
		// 虽然你传的是int普通变量n，不是引用，但是编译器会帮你转成n的指针(&n)然后再传到函数中
		func(n); 
		std::cout<<n<<std::endl; // 输出是8


		第二部分：
		先还原值n=5;
		int &ref = n; // 这里其实就是拿到了n的指针给了ref，即int* const ref = &n;
		func(ref); // 函数的传参是值传递，就把ref的值(n的地址传过去了)
		std::cout<<n<<std::endl; // 输出还是8

		其实，两个部分都在说明一个问题，引用的传递本质上还是传指针，那就是函数形参只需要4个字节(在x86)
		1、也就是说编译器做了优化，你传过去是一个引用，那编译器就会直接以值传递的方式，把引用的值(也就是对应变量n的指针)
		传到函数参数中，并且在使用时，都会对那个引用偷偷进行解引用(这个是编译器暗操作，我们看不到，只觉得只需要变量名
		就可以改变传过去变量n的值，仅此而已)
		2、当你传过去是一个普通变量n，编译器又会默认把实参变量转成&n，再传给编译器，形参的引用接收到的值其实还是
		变量n的指针，同样地，在使用函数中的引用时，编译器也会偷偷在解引用，所以我们才不需要写*而已

	}


*/

void func03()
{
	// 对引用的深刻理解及运用
	int a = 10;
	int b = 20;
	int* p = &a; 
	// int** const pRef = &p; 这个就是指向int指针的引用，它的值不能改，但是可以改它指向空间的值
	// 也就是一级指针p的值，换句话说就是可以把p指向的&a改为p指向&b
	// 本质上ppRef是一个二级常指针
	int* (&ppRef) = p; 
	ppRef = &b; // 这就是修改的方式
	std::cout << "*ppRef = " << *ppRef << std::endl;
	std::cout << "*p = " << *p << std::endl;
}


// 虽然说直接传个int的数据空间没有消耗多少，但是如果传一个很大的结构体的话
// 可能内存就会很大，因此就可以展现出引用的作用了
void func01(int a)// 形参
{
	cout << "a = " << a << endl;
}

// C++中不叫指针，叫引用
// 引用是什么？引用是做什么的？
// 1、有着和C语言的指针一样功能；
// 2、引用的作用是给空间取别名(也就是给空间取外号)
// 3、并且使得语法更加简洁清晰，不用整天取*且分清楚指针与指针的关系

void test02()
{
	int a = 10;
	// 给a的空间取别名叫b
	// 也就是说有一段空间的名字即叫a也叫b
	// 操作a和操作b是一样的，如下：
	int& b = a; 
	b = 100;
	cout << "b = " << b << endl;

	cout << "-----------------" << endl;
	// 这个对比上面那个来说，更为复杂，还要做一些解引用的操作，这样特别麻烦
	int a1 = 20;
	int* p = (int*)&a1;
	*p = 200;
	cout << "a1 = " << a1 << endl;
}

// 其实本质上就是把一个变量的名字传过来，然后起了个别名a
// 也就是说用的还是同一个空间，还指针的效果一样
void func02(int &a) // 也就是说本质上隐藏了一步  int &a = a;
{
	a = 200;
}

void test03()
{
	int a = 20;
	func02(a);
	cout << "a = " << a << endl;
}


int main()
{
	test02();
	//int a = 10;
	//func01(a); // 实参
	cout << "------------------" << endl;
	test03();


	func03();


	return 0;
}
