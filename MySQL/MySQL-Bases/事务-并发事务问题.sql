/*
        事务的并发问题是指当多个事务同时访问和修改数据库时可能出现的问题。这些问题可能导致数据不一致或错误的结果。为了
    更好地理解这些并发问题，我们可以用一些日常生活中的例子来类比。

    (1)脏读（Dirty Read）：想象你和朋友在图书馆学习，你的朋友正在写一篇文章，而你正在阅读他的草稿。突然，你的朋友决定不
    喜欢这个草稿，将其删除。如果你基于这个草稿做了笔记，那么你的笔记就是基于一个不再存在的信息，这就是脏读。在数据库中，如
    果一个事务读取了另一个未提交事务的修改，而这些修改后来被回滚了，那么读取的数据就是“脏”的。(一个事务读到另一个事务还没
    提交的数据)

    (2)不可重复读（Non-repeatable Read）：假设你在图书馆读一本书，第一次读到某个章节时，书中的信息是A。当你再次回到同
    一章节时，信息变成了B。如果你需要两次读取相同的信息来完成你的研究，但信息发生了变化，这就导致了不可重复读。在数据库
    中，这意味着在一个事务内，同一查询返回了不同的结果，因为其他事务在两次查询之间修改了数据。(一个事务先后读取同一条记录，但
    两次读取的数据不同，称之为不可重复读)
    本质：在一个事务中，两次读取同一条记录，结果不同。
    原因：其他事务在两次读取之间修改了该记录。

    (3)幻读（Phantom Read）：想象你是一家餐厅的经理，你需要确保餐厅有足够的食材来满足顾客的需求。你决定检查一下库存清单，看
    看有多少种类的蔬菜。第一次检查时，清单显示有10种蔬菜。你记下了这个数字，并计划根据这个数字来订购食材。然而，在你做出订购决
    定之前，你的助手也在同时工作。他接到了一个电话，是供应商通知说他们刚刚送来了5种新的蔬菜。你的助手更新了库存清单，现在清单上
    有15种蔬菜。当你再次检查清单时，你惊讶地发现蔬菜的种类增加了。这些新增加的蔬菜就像“幻影”一样，因为你没有预料到会有新的蔬菜
    出现。你之前的订购计划是基于10种蔬菜的，但现在你需要重新考虑，因为你没有预料到会有额外的蔬菜。在数据库中，幻读就是类似的情
    况。当一个事务在两次查询中读取了相同范围的数据，但第二次查询时发现了额外的行，这些行在第一次查询时不存在。这通常发生在有其
    他事务在两次查询之间插入了新的数据行。为了防止幻读，数据库系统提供了不同的隔离级别，如可重复读和串行化。这些级别可以确保事
    务在执行期间看到的数据是一致的，防止了“幻影”数据的出现。通过选择合适的隔离级别，可以确保数据的一致性，同时平衡系统的性能和
    并发需求。(一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了"幻影")
    本质：在一个事务中，两次执行相同的查询，结果集不同。
    原因：其他事务在两次查询之间插入或删除了记录。

        为了解决这些并发问题，数据库管理系统提供了不同的隔离级别，如读未提交（Read Uncommitted）、读已提交（Read Committed）、可
    重复读（Repeatable Read）和串行化（Serializable）。每个级别都有不同的保护措施来防止上述问题，但同时也会影响系统的性能和并发能
    力。通过选择合适的隔离级别，可以平衡数据一致性和系统性能的需求。
*/
